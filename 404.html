<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Viewer</title>
    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: sans-serif; background: #525659; }
        #loader {
            display: flex; justify-content: center; align-items: center; height: 100%; color: white;
            flex-direction: column;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.3); border-radius: 50%; border-top: 4px solid white;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        iframe { width: 100%; height: 100%; border: none; display: none; }
        #error-msg { color: #ff6b6b; text-align: center; display: none; padding: 20px; margin-top: 20%; }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p>Locating document...</p>
    </div>

    <div id="error-msg"></div>
    <iframe id="pdf-frame"></iframe>

    <script>
        // --- CONFIGURATION ---
        const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbyAemGs7FBW94fcx0Ncrhi_caJvUfAutejnPvzgGt6S66yfOW_pY36rQGr0VgFTQUUALg/exec"; 
        const EXPECTED_PATH = "/invoice/"; // The URL path prefix you want to support
        // ---------------------

        async function init() {
            // 1. Get the current URL path (e.g., "/invoice/2023.pdf")
            const path = window.location.pathname;
            
            // 2. Check if the URL matches our expected pattern
            if (!path.includes(EXPECTED_PATH)) {
                // If the user visits the root page or a wrong path, show a generic 404 or redirect home
                document.body.innerHTML = "<h1 style='color:white;text-align:center;margin-top:20%'>404 - Page Not Found</h1>";
                return;
            }

            // 3. Extract the filename from the end of the URL
            // splits "/invoice/2023.pdf" -> ["", "invoice", "2023.pdf"] -> "2023.pdf"
            const fileName = path.split('/').pop(); 

            // Decode URI components (handles spaces like "Invoice%201.pdf")
            const cleanFileName = decodeURIComponent(fileName);

            if (!cleanFileName || cleanFileName === "") {
                showError("No filename detected in URL.");
                return;
            }

            // 4. Update the page title to match the file
            document.title = cleanFileName;

            // 5. Fetch the PDF data
            await loadPdf(cleanFileName);
        }

        async function loadPdf(fileName) {
            try {
                // Call Google Apps Script with the extracted filename
                const response = await fetch(`${SCRIPT_URL}?file=${encodeURIComponent(fileName)}`);
                const result = await response.json();

                if (result.status !== 'success') {
                    throw new Error(result.message || "File not found in database.");
                }

                // Convert Base64 to Blob
                const byteCharacters = atob(result.data);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const pdfBlob = new Blob([byteArray], {type: "application/pdf"});

                // Display PDF
                const pdfUrl = URL.createObjectURL(pdfBlob);
                const iframe = document.getElementById('pdf-frame');
                iframe.src = pdfUrl;
                
                document.getElementById('loader').style.display = 'none';
                iframe.style.display = 'block';

            } catch (error) {
                showError("Error: " + error.message);
            }
        }

        function showError(msg) {
            document.getElementById('loader').style.display = 'none';
            const errDiv = document.getElementById('error-msg');
            errDiv.innerText = msg;
            errDiv.style.display = 'block';
        }

        // Start the logic
        init();
    </script>
</body>
</html> -->





<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Viewer</title>
    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: sans-serif; background: #525659; }
        #loader {
            display: flex; justify-content: center; align-items: center; height: 100%; color: white;
            flex-direction: column;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.3); border-radius: 50%; border-top: 4px solid white;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        iframe { width: 100%; height: 100%; border: none; display: none; }
        #error-msg { color: #ff6b6b; text-align: center; display: none; padding: 20px; font-size: 18px; margin-top: 50px;}
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p>Locating secure document...</p>
    </div>

    <div id="error-msg"></div>

    <iframe id="pdf-frame"></iframe>

    <script>
        const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbyAemGs7FBW94fcx0Ncrhi_caJvUfAutejnPvzgGt6S66yfOW_pY36rQGr0VgFTQUUALg/exec"; 

        async function init() {
            // 1. Get the path from the URL (e.g., "/invoice/2023.pdf")
            const path = window.location.pathname;
            
            // 2. Extract the filename. 
            // This logic takes the last segment of the URL. 
            // Example: "yourcompany.com/invoice/2023.pdf" -> "2023.pdf"
            const segments = path.split('/').filter(Boolean);
            const fileName = segments.length > 0 ? segments[segments.length - 1] : null;

            // If user just goes to root domain, show error or redirect
            if (!fileName || !fileName.toLowerCase().endsWith('.pdf')) {
                showError("Invalid URL. Please check the link.");
                return;
            }

            try {
                // 3. Call the API with the extracted filename
                const response = await fetch(`${SCRIPT_URL}?file=${encodeURIComponent(fileName)}`);
                const result = await response.json();

                if (result.status !== 'success') {
                    throw new Error("Document not found in database.");
                }

                // 4. Decode Base64 and display
                const byteCharacters = atob(result.data);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const pdfBlob = new Blob([byteArray], {type: "application/pdf"});
                const pdfUrl = URL.createObjectURL(pdfBlob);

                const iframe = document.getElementById('pdf-frame');
                iframe.src = pdfUrl;
                
                document.getElementById('loader').style.display = 'none';
                iframe.style.display = 'block';
                
                // Optional: Update page title
                document.title = result.filename;

            } catch (error) {
                showError(error.message);
            }
        }

        function showError(msg) {
            document.getElementById('loader').style.display = 'none';
            const errDiv = document.getElementById('error-msg');
            errDiv.innerText = msg;
            errDiv.style.display = 'block';
        }

        init();
    </script>
</body>
</html> -->



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure File Viewer</title>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    
    <style>
        body, html { margin: 0; padding: 0; height: 100%; font-family: sans-serif; background: #f4f4f4; }
        
        /* Loader */
        #loader {
            display: flex; justify-content: center; align-items: center; height: 100%; color: #333;
            flex-direction: column;
        }
        .spinner {
            border: 4px solid rgba(0,0,0,0.1); border-radius: 50%; border-top: 4px solid #333;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* PDF Viewer (Full Screen) */
        iframe { width: 100%; height: 100%; border: none; display: none; }

        /* Excel Viewer (Table) */
        #excel-container { 
            display: none; padding: 40px; max-width: 1000px; margin: 0 auto; background: white; 
            box-shadow: 0 0 10px rgba(0,0,0,0.1); min-height: 100vh; overflow: auto;
        }
        #excel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid #ddd; }
        
        /* Excel Table Styling */
        table { border-collapse: collapse; width: 100%; font-size: 14px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f8f9fa; font-weight: bold; }
        tr:nth-child(even) { background-color: #f9f9f9; }

        /* Buttons */
        .btn { 
            padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; cursor: pointer; border: none; font-size: 14px;
        }
        .btn:hover { background: #0056b3; }
        
        #error-msg { color: #dc3545; text-align: center; display: none; padding: 50px; }



               
    /* Add styling for the fallback button */
    #fallback-link {
        display: none; /* Starts hidden, shown if iframe fails */
        margin-top: 20px;
        text-align: center;
        padding: 10px;
        background-color: #ffc107; /* Warning color */
        color: #333;
        border-radius: 5px;
        text-decoration: none;
        font-weight: bold;
    }

    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p>Fetching secure document...</p>
    </div>

    <div id="error-msg"></div>

    <iframe id="pdf-frame"></iframe>

    <div id="excel-container">
        <div id="excel-header">
            <h2 id="file-title">Invoice</h2>
            <button id="download-btn" class="btn">Download Original File</button>
        </div>
        <div id="excel-content"></div>
    </div>


    
<a id="fallback-link" href="#" target="_blank">
    ⚠️ Document not loading? Tap here to download and view.
</a>



    
    <script>
        const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbyAemGs7FBW94fcx0Ncrhi_caJvUfAutejnPvzgGt6S66yfOW_pY36rQGr0VgFTQUUALg/exec"; 

        async function init() {
            // Extract filename from URL (e.g., "2025.xls")
            const path = window.location.pathname;
            const segments = path.split('/').filter(Boolean);
            const fileName = segments.length > 0 ? segments[segments.length - 1] : null;

            if (!fileName) {
                showError("No filename found in URL.");
                return;
            }

            // Detect File Type
            const ext = fileName.split('.').pop().toLowerCase();
            const isExcel = ['xls', 'xlsx', 'csv'].includes(ext);
            const isPdf = ['pdf'].includes(ext);

            if (!isExcel && !isPdf) {
                showError("Unsupported file type: " + ext);
                return;
            }

            try {
                // Fetch Data
                const response = await fetch(`${SCRIPT_URL}?file=${encodeURIComponent(fileName)}`);
                const result = await response.json();

                if (result.status !== 'success') {
                    throw new Error("File not found in database.");
                }

                // Handle Rendering based on type
                if (isPdf) {
                    renderPdf(result.data);
                } else if (isExcel) {
                    renderExcel(result.data, result.filename);
                }

            } catch (error) {
                showError(error.message);
            }
        }


        // works for desktop
        // function renderPdf(base64Data) {
        //     const blob = base64ToBlob(base64Data, "application/pdf");
        //     const url = URL.createObjectURL(blob);
        //     const iframe = document.getElementById('pdf-frame');
        //     iframe.src = url;
        //     iframe.style.display = 'block';
        //     document.getElementById('loader').style.display = 'none';
        // }


// works for mobile but address change
        // --- Replace the existing renderPdf function with this: ---
// function renderPdf(base64Data) {
//     const blob = base64ToBlob(base64Data, "application/pdf");
//     const pdfUrl = URL.createObjectURL(blob);
    
//     // Switch Views - Hide the loader before navigating
//     document.getElementById('loader').style.display = 'none';

//     // **CRITICAL FIX FOR MOBILE BROWSERS**
//     // Instead of setting the iframe source, navigate the entire page 
//     // to the Blob URL. This forces the mobile OS/browser to use its
//     // native full-screen PDF viewer, which is much more reliable.
//     window.location.assign(pdfUrl);
// }






    // Existing helper function remains the same
    function base64ToBlob(base64, mimeType) {
        const byteCharacters = atob(base64);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], {type: mimeType});
    }

    // --- NEW renderPdf Function ---
    function renderPdf(base64Data) {
        const blob = base64ToBlob(base64Data, "application/pdf");
        const pdfUrl = URL.createObjectURL(blob);
        
        const iframe = document.getElementById('pdf-frame');
        const fallbackLink = document.getElementById('fallback-link');

        // 1. Set the iframe source
        iframe.src = pdfUrl;
        
        // 2. Set the fallback link href
        // This makes the Blob URL available for direct download if the iframe fails.
        fallbackLink.href = pdfUrl;

        // 3. Switch Views
        document.getElementById('loader').style.display = 'none';
        iframe.style.display = 'block';

        // 4. Set a timer to show the fallback link if the iframe hasn't loaded 
        // after a few seconds (common issue on slow mobile connections/memory limits).
        setTimeout(() => {
            // Check if the iframe is still loading or likely failed
            if (iframe.style.display === 'block') {
                fallbackLink.style.display = 'block';
            }
        }, 5000); // 5 second delay

        // Ensure the iframe removes the fallback link once the PDF is displayed
        iframe.onload = () => {
            fallbackLink.style.display = 'none';
        };
    }

// -----------------------------------------------------------

        function renderExcel(base64Data, filename) {
            // 1. Read the Base64 data using SheetJS
            const workbook = XLSX.read(base64Data, {type: 'base64'});

            // 2. Get the first sheet name
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];

            // 3. Convert sheet to HTML Table
            const htmlTable = XLSX.utils.sheet_to_html(worksheet);

            // 4. Inject into DOM
            document.getElementById('excel-content').innerHTML = htmlTable;
            document.getElementById('file-title').innerText = filename;
            
            // 5. Setup Download Button
            document.getElementById('download-btn').onclick = () => {
                const blob = base64ToBlob(base64Data, "application/vnd.ms-excel");
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.click();
            };

            // Switch Views
            document.getElementById('loader').style.display = 'none';
            document.getElementById('excel-container').style.display = 'block';
        }

        // Helper: Convert Base64 to Blob
        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], {type: mimeType});
        }

        function showError(msg) {
            document.getElementById('loader').style.display = 'none';
            const errDiv = document.getElementById('error-msg');
            errDiv.innerText = msg;
            errDiv.style.display = 'block';
        }

        init();
    </script>
</body>
</html>
